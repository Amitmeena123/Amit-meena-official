
class AdvancedObjectDetector {
    constructor() {
        this.video = document.getElementById('video');
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.status = document.getElementById('status');
        this.detectionsDiv = document.getElementById('detections');
        
        this.model = null;
        this.isDetecting = false;
        this.stream = null;
        this.animationId = null;
        
        // Previous frame data for speed calculation
        this.previousDetections = new Map();
        this.frameCount = 0;
        this.lastFrameTime = Date.now();
        
        // Color mapping for objects
        this.colorNames = {
            'red': '‡§≤‡§æ‡§≤',
            'blue': '‡§®‡•Ä‡§≤‡§æ', 
            'green': '‡§π‡§∞‡§æ',
            'yellow': '‡§™‡•Ä‡§≤‡§æ',
            'black': '‡§ï‡§æ‡§≤‡§æ',
            'white': '‡§∏‡§´‡•á‡§¶',
            'gray': '‡§∏‡•ç‡§≤‡•á‡§ü‡•Ä',
            'orange': '‡§®‡§æ‡§∞‡§Ç‡§ó‡•Ä',
            'purple': '‡§¨‡•à‡§Ç‡§ó‡§®‡•Ä',
            'pink': '‡§ó‡•Å‡§≤‡§æ‡§¨‡•Ä',
            'brown': '‡§≠‡•Ç‡§∞‡§æ',
            'silver': '‡§ö‡§æ‡§Ç‡§¶‡•Ä'
        };

        // Enhanced target objects with Hindi names - Advanced Detection
        this.targetObjects = {
            // Vehicles - ‡§ó‡§æ‡§°‡§º‡§ø‡§Ø‡§æ‡§Ç
            'car': '‡§ï‡§æ‡§∞/‡§ó‡§æ‡§°‡§º‡•Ä',
            'bus': '‡§¨‡§∏',
            'person': '‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø/‡§Ü‡§¶‡§Æ‡•Ä',
            'truck': '‡§ü‡•ç‡§∞‡§ï/‡§≤‡•â‡§∞‡•Ä',
            'motorcycle': '‡§Æ‡•ã‡§ü‡§∞‡§∏‡§æ‡§á‡§ï‡§ø‡§≤/‡§¨‡§æ‡§á‡§ï',
            'bicycle': '‡§∏‡§æ‡§á‡§ï‡§ø‡§≤/‡§¨‡§æ‡§á‡§∏‡§ø‡§ï‡§≤',
            'auto': '‡§ë‡§ü‡•ã/‡§∞‡§ø‡§ï‡•ç‡§∂‡§æ',
            'jeep': '‡§ú‡•Ä‡§™',
            'van': '‡§µ‡•à‡§®',
            'taxi': '‡§ü‡•à‡§ï‡•ç‡§∏‡•Ä',
            
            // Animals - ‡§ú‡§æ‡§®‡§µ‡§∞
            'cow': '‡§ó‡§æ‡§Ø',
            'dog': '‡§ï‡•Å‡§§‡•ç‡§§‡§æ',
            'cat': '‡§¨‡§ø‡§≤‡•ç‡§≤‡•Ä',
            'horse': '‡§ò‡•ã‡§°‡§º‡§æ',
            'bird': '‡§™‡§ï‡•ç‡§∑‡•Ä',
            'sheep': '‡§≠‡•á‡§°‡§º',
            'elephant': '‡§π‡§æ‡§•‡•Ä',
            'bear': '‡§≠‡§æ‡§≤‡•Ç',
            'zebra': '‡§ú‡§º‡•á‡§¨‡•ç‡§∞‡§æ',
            'giraffe': '‡§ú‡§ø‡§∞‡§æ‡§´',
            
            // Transport - ‡§™‡§∞‡§ø‡§µ‡§π‡§®
            'boat': '‡§®‡§æ‡§µ/‡§¨‡•ã‡§ü',
            'airplane': '‡§π‡§µ‡§æ‡§à ‡§ú‡§π‡§æ‡§ú',
            'train': '‡§ü‡•ç‡§∞‡•á‡§®/‡§∞‡•á‡§≤‡§ó‡§æ‡§°‡§º‡•Ä',
            
            // Traffic & Street Items
            'traffic light': '‡§ü‡•ç‡§∞‡•à‡§´‡§ø‡§ï ‡§≤‡§æ‡§á‡§ü',
            'fire hydrant': '‡§´‡§æ‡§Ø‡§∞ ‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•á‡§Ç‡§ü',
            'stop sign': '‡§∏‡•ç‡§ü‡•â‡§™ ‡§∏‡§æ‡§á‡§®',
            'parking meter': '‡§™‡§æ‡§∞‡•ç‡§ï‡§ø‡§Ç‡§ó ‡§Æ‡•Ä‡§ü‡§∞',
            'bench': '‡§¨‡•á‡§Ç‡§ö',
            
            // Personal Items
            'backpack': '‡§¨‡•à‡§ï‡§™‡•à‡§ï',
            'umbrella': '‡§õ‡§æ‡§§‡§æ',
            'handbag': '‡§π‡•à‡§Ç‡§°‡§¨‡•à‡§ó/‡§™‡§∞‡•ç‡§∏',
            'tie': '‡§ü‡§æ‡§à',
            'suitcase': '‡§∏‡•Ç‡§ü‡§ï‡•á‡§∏',
            
            // Sports & Recreation
            'frisbee': '‡§´‡•ç‡§∞‡§ø‡§∏‡§¨‡•Ä',
            'skis': '‡§∏‡•ç‡§ï‡•Ä',
            'snowboard': '‡§∏‡•ç‡§®‡•ã‡§¨‡•ã‡§∞‡•ç‡§°',
            'sports ball': '‡§ñ‡•á‡§≤ ‡§ï‡•Ä ‡§ó‡•á‡§Ç‡§¶',
            'kite': '‡§™‡§§‡§Ç‡§ó',
            'baseball bat': '‡§¨‡•á‡§∏‡§¨‡•â‡§≤ ‡§¨‡•à‡§ü',
            'baseball glove': '‡§¨‡•á‡§∏‡§¨‡•â‡§≤ ‡§¶‡§∏‡•ç‡§§‡§æ‡§®‡§æ',
            'skateboard': '‡§∏‡•ç‡§ï‡•á‡§ü‡§¨‡•ã‡§∞‡•ç‡§°',
            'surfboard': '‡§∏‡§∞‡•ç‡§´‡§¨‡•ã‡§∞‡•ç‡§°',
            'tennis racket': '‡§ü‡•á‡§®‡§ø‡§∏ ‡§∞‡•à‡§ï‡•á‡§ü',
            
            // Additional objects for better detection
            'bottle': '‡§¨‡•ã‡§§‡§≤',
            'wine glass': '‡§µ‡§æ‡§á‡§® ‡§ó‡•ç‡§≤‡§æ‡§∏',
            'cup': '‡§ï‡§™',
            'fork': '‡§ï‡§æ‡§Ç‡§ü‡§æ',
            'knife': '‡§ö‡§æ‡§ï‡•Ç',
            'spoon': '‡§ö‡§Æ‡•ç‡§Æ‡§ö',
            'bowl': '‡§ï‡§ü‡•ã‡§∞‡§æ',
            'banana': '‡§ï‡•á‡§≤‡§æ',
            'apple': '‡§∏‡•á‡§¨',
            'sandwich': '‡§∏‡•à‡§Ç‡§°‡§µ‡§ø‡§ö',
            'orange': '‡§∏‡§Ç‡§§‡§∞‡§æ',
            'broccoli': '‡§¨‡•ç‡§∞‡•ã‡§ï‡•ã‡§≤‡•Ä',
            'carrot': '‡§ó‡§æ‡§ú‡§∞',
            'hot dog': '‡§π‡•â‡§ü ‡§°‡•â‡§ó',
            'pizza': '‡§™‡§ø‡§ú‡§º‡•ç‡§ú‡§º‡§æ',
            'donut': '‡§°‡•ã‡§®‡§ü',
            'cake': '‡§ï‡•á‡§ï',
            'chair': '‡§ï‡•Å‡§∞‡•ç‡§∏‡•Ä',
            'couch': '‡§∏‡•ã‡§´‡§æ',
            'potted plant': '‡§ó‡§Æ‡§≤‡§æ',
            'bed': '‡§¨‡§ø‡§∏‡•ç‡§§‡§∞',
            'dining table': '‡§ñ‡§æ‡§®‡•á ‡§ï‡•Ä ‡§Æ‡•á‡§ú‡§º',
            'toilet': '‡§∂‡•å‡§ö‡§æ‡§≤‡§Ø',
            'tv': '‡§ü‡•Ä‡§µ‡•Ä/‡§ü‡•á‡§≤‡•Ä‡§µ‡§ø‡§ú‡§º‡§®',
            'laptop': '‡§≤‡•à‡§™‡§ü‡•â‡§™',
            'mouse': '‡§Æ‡§æ‡§â‡§∏',
            'remote': '‡§∞‡§ø‡§Æ‡•ã‡§ü',
            'keyboard': '‡§ï‡•Ä‡§¨‡•ã‡§∞‡•ç‡§°',
            'cell phone': '‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§´‡•ã‡§®',
            'microwave': '‡§Æ‡§æ‡§á‡§ï‡•ç‡§∞‡•ã‡§µ‡•á‡§µ',
            'oven': '‡§ì‡§µ‡§®',
            'toaster': '‡§ü‡•ã‡§∏‡•ç‡§ü‡§∞',
            'sink': '‡§∏‡§ø‡§Ç‡§ï',
            'refrigerator': '‡§´‡•ç‡§∞‡§ø‡§ú',
            'book': '‡§ï‡§ø‡§§‡§æ‡§¨',
            'clock': '‡§ò‡§°‡§º‡•Ä',
            'vase': '‡§´‡•Ç‡§≤‡§¶‡§æ‡§®',
            'scissors': '‡§ï‡•à‡§Ç‡§ö‡•Ä',
            'teddy bear': '‡§ü‡•á‡§°‡•Ä ‡§¨‡§ø‡§Ø‡§∞',
            'hair drier': '‡§π‡•á‡§Ø‡§∞ ‡§°‡•ç‡§∞‡§æ‡§Ø‡§∞',
            'toothbrush': '‡§ü‡•Ç‡§•‡§¨‡•ç‡§∞‡§∂'
        };
        
        this.colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
            '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
            '#74B9FF', '#FD79A8', '#FDCB6E', '#6C5CE7',
            '#A29BFE', '#FD79A8', '#00B894', '#E17055'
        ];
        
        // Hand detection model
        this.handModel = null;
        
        this.init();
    }
    
    async init() {
        this.setupEventListeners();
        await this.loadModel();
        this.setupFullscreen();
        
        // Auto start camera after model loads
        setTimeout(() => {
            if (this.model && !this.isDetecting) {
                this.startCamera();
            }
        }, 2000);
    }
    
    setupEventListeners() {
        this.startBtn.addEventListener('click', () => this.startCamera());
        this.stopBtn.addEventListener('click', () => this.stopCamera());
        
        // Auto-start indication
        this.startBtn.innerHTML = 'üé• Auto Starting...';
        this.startBtn.disabled = true;
        
        // Fullscreen controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                this.toggleFullscreen();
            }
            if (e.key === 'Escape') {
                this.exitFullscreen();
            }
        });
    }
    
    setupFullscreen() {
        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.innerHTML = 'üîç Fullscreen (F)';
        fullscreenBtn.style.background = 'linear-gradient(45deg, #667eea, #764ba2)';
        fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
        document.querySelector('.controls').appendChild(fullscreenBtn);
    }
    
    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.log('Fullscreen error:', err);
            });
        } else {
            document.exitFullscreen();
        }
    }
    
    exitFullscreen() {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        }
    }
    
    async loadModel() {
        try {
            this.updateStatus('ü§ñ Advanced AI Model + Hand Detection ‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...', 'loading');
            
            // Wait for TensorFlow to be ready
            await tf.ready();
            console.log('‚úÖ TensorFlow.js is ready');
            
            // Load object detection model
            this.model = await cocoSsd.load({
                base: 'mobilenet_v2',
                modelUrl: undefined // Use default CDN
            });
            
            console.log('‚úÖ COCO-SSD Model loaded successfully');
            this.updateStatus('‚úÖ Advanced AI Model + Color Detection ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à! Auto-starting camera...', 'ready');
            this.startBtn.innerHTML = 'üé• Start Advanced Camera';
            this.startBtn.disabled = false;
            
        } catch (error) {
            console.error('Model loading error:', error);
            this.updateStatus('üîÑ Model retry ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...', 'loading');
            
            // Retry loading with fallback
            try {
                await new Promise(resolve => setTimeout(resolve, 2000));
                this.model = await cocoSsd.load();
                console.log('‚úÖ Model loaded on retry');
                this.updateStatus('‚úÖ AI Model ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à (Retry Success)!', 'ready');
            } catch (retryError) {
                console.error('Retry failed:', retryError);
                this.updateStatus('‚ùå Model load failed. Internet connection check ‡§ï‡§∞‡•á‡§Ç‡•§', 'error');
            }
        }
    }
    
    async startCamera() {
        try {
            this.updateStatus('üì∑ High Quality Camera ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...', 'loading');
            
            const constraints = {
                video: {
                    width: { ideal: 1920, min: 640 },
                    height: { ideal: 1080, min: 480 },
                    frameRate: { ideal: 60, min: 30 },
                    facingMode: 'environment',
                    focusMode: 'continuous',
                    exposureMode: 'continuous',
                    whiteBalanceMode: 'continuous'
                }
            };
            
            this.stream = await navigator.mediaDevices.getUserMedia(constraints);
            this.video.srcObject = this.stream;
            
            this.video.onloadedmetadata = () => {
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.startDetection();
            };
            
            this.startBtn.disabled = true;
            this.stopBtn.disabled = false;
            this.frameCount = 0;
            this.lastFrameTime = Date.now();
            
        } catch (error) {
            console.error('Camera error:', error);
            this.updateStatus('‚ùå Camera access ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§ Permission ‡§¶‡•á‡§Ç‡•§', 'error');
        }
    }
    
    stopCamera() {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        this.isDetecting = false;
        this.startBtn.disabled = false;
        this.stopBtn.disabled = true;
        this.previousDetections.clear();
        
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.clearDetections();
        this.updateStatus('üì∑ Camera ‡§¨‡§Ç‡§¶‡•§ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è "Start Camera" ‡§¶‡§¨‡§æ‡§è‡§Ç‡•§', 'ready');
    }
    
    async startDetection() {
        // Enhanced model check
        if (!this.model) {
            this.updateStatus('üîÑ AI Model loading... ‡§ï‡•É‡§™‡§Ø‡§æ ‡§á‡§Ç‡§§‡§ú‡§º‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç', 'loading');
            
            // Wait and retry
            for (let i = 0; i < 10; i++) {
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (this.model) break;
                this.updateStatus(`üîÑ Model loading... (${i + 1}/10)`, 'loading');
            }
            
            if (!this.model) {
                this.updateStatus('‚ùå AI Model load ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§Ü‡•§ Page refresh ‡§ï‡§∞‡•á‡§Ç‡•§', 'error');
                return;
            }
        }
        
        this.isDetecting = true;
        this.updateStatus('üîç Advanced Live Detection ‡§∂‡•Å‡§∞‡•Ç! ‡§∏‡§≠‡•Ä objects detect ‡§π‡•ã ‡§∞‡§π‡•á ‡§π‡•à‡§Ç...', 'ready');
        this.detectObjects();
    }
    
    async detectObjects() {
        if (!this.isDetecting || this.video.readyState !== 4) {
            this.animationId = requestAnimationFrame(() => this.detectObjects());
            return;
        }
        
        try {
            // Check if model and video are ready
            if (!this.model || !this.video || this.video.videoWidth === 0) {
                this.animationId = requestAnimationFrame(() => this.detectObjects());
                return;
            }
            
            const currentTime = Date.now();
            const predictions = await this.model.detect(this.video);
            
            // Filter and enhance predictions
            const enhancedPredictions = this.enhancePredictions(predictions, currentTime);
            
            this.drawPredictions(enhancedPredictions, currentTime);
            this.updateDetectionsList(enhancedPredictions);
            this.updatePreviousDetections(enhancedPredictions, currentTime);
            
            this.frameCount++;
            
        } catch (error) {
            console.error('Detection error:', error.message || error);
            // Don't stop detection on errors, just log them
        }
        
        this.animationId = requestAnimationFrame(() => this.detectObjects());
    }
    
    enhancePredictions(predictions, currentTime) {
        return predictions
            .filter(prediction => {
                const className = prediction.class.toLowerCase();
                // Advanced filtering for better accuracy
                let isTargetObject = Object.keys(this.targetObjects).includes(className);
                
                // Map similar objects to target objects
                const objectMappings = {
                    'motorbike': 'motorcycle',
                    'bike': 'bicycle',
                    'rickshaw': 'auto',
                    'auto-rickshaw': 'auto',
                    'suv': 'jeep',
                    '4x4': 'jeep'
                };
                
                if (!isTargetObject && objectMappings[className]) {
                    isTargetObject = true;
                }
                
                // Special handling for vehicles and people (priority objects)
                const priorityObjects = ['car', 'bus', 'person', 'truck', 'motorcycle', 'bicycle', 'auto', 'jeep'];
                const isPriorityObject = priorityObjects.includes(className) || 
                                      priorityObjects.includes(objectMappings[className]);
                
                if (isPriorityObject) {
                    return prediction.score > 0.08; // Very low threshold for vehicles
                }
                
                return isTargetObject && prediction.score > 0.12;
            })
            .map(prediction => {
                const id = this.generateObjectId(prediction);
                const previousData = this.previousDetections.get(id);
                
                let speed = 0;
                let direction = '';
                
                if (previousData) {
                    const timeDiff = (currentTime - previousData.time) / 1000; // seconds
                    
                    if (timeDiff > 0.1) { // Avoid division by very small numbers
                        const [x1, y1] = this.getBBoxCenter(prediction.bbox);
                        const [x2, y2] = this.getBBoxCenter(previousData.bbox);
                        
                        const distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
                        const pixelsPerSecond = distance / timeDiff;
                    
                    // Enhanced speed calculation based on object type
                        let speedMultiplier = 0.1;
                        const className = prediction.class.toLowerCase();
                        
                        // Different multipliers for different object types
                        if (['car', 'bus', 'truck'].includes(className)) {
                            speedMultiplier = 0.15; // Higher for vehicles
                        } else if (['motorcycle', 'bicycle'].includes(className)) {
                            speedMultiplier = 0.12;
                        } else if (className === 'person') {
                            speedMultiplier = 0.05; // Lower for people
                        }
                        
                        speed = Math.max(0, Math.round(pixelsPerSecond * speedMultiplier));
                        
                        // Enhanced direction calculation
                        const deltaX = x1 - x2;
                        const deltaY = y1 - y2;
                        
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            direction = deltaX > 5 ? '‚Üí ‡§¶‡§æ‡§è‡§Ç' : deltaX < -5 ? '‚Üê ‡§¨‡§æ‡§è‡§Ç' : '‚äô ‡§∏‡•ç‡§•‡§ø‡§∞';
                        } else {
                            direction = deltaY > 5 ? '‚Üì ‡§®‡•Ä‡§ö‡•á' : deltaY < -5 ? '‚Üë ‡§ä‡§™‡§∞' : '‚äô ‡§∏‡•ç‡§•‡§ø‡§∞';
                        }
                        
                        // Add movement intensity
                        if (distance > 20) {
                            direction += ' ‡§§‡•á‡§ú‡§º';
                        } else if (distance > 10) {
                            direction += ' ‡§Æ‡§ß‡•ç‡§Ø‡§Æ';
                        } else if (distance > 3) {
                            direction += ' ‡§ß‡•Ä‡§Æ‡§æ';
                        }
                    }
                }
                
                // Map object class to target object if needed
                let finalClass = prediction.class.toLowerCase();
                const objectMappings = {
                    'motorbike': 'motorcycle',
                    'bike': 'bicycle',
                    'rickshaw': 'auto',
                    'auto-rickshaw': 'auto',
                    'suv': 'jeep',
                    '4x4': 'jeep'
                };
                
                if (objectMappings[finalClass]) {
                    finalClass = objectMappings[finalClass];
                }
                
                // Detect object color
                const objectColor = this.detectObjectColor(prediction.bbox);
                
                // Special analysis for persons
                let personAttributes = null;
                if (finalClass === 'person') {
                    personAttributes = this.analyzePersonAttributes(prediction.bbox);
                }
                
                return {
                    ...prediction,
                    id,
                    speed,
                    direction,
                    hindiName: this.targetObjects[finalClass] || prediction.class,
                    detectedAs: finalClass,
                    color: objectColor,
                    personAttributes: personAttributes
                };
            });
    }
    
    generateObjectId(prediction) {
        const [x, y, width, height] = prediction.bbox;
        return `${prediction.class}_${Math.round(x/50)}_${Math.round(y/50)}`;
    }
    
    // Advanced color detection function
    detectObjectColor(bbox) {
        const [x, y, width, height] = bbox;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Create small canvas for color sampling
        canvas.width = width;
        canvas.height = height;
        
        // Draw the object region
        ctx.drawImage(this.video, x, y, width, height, 0, 0, width, height);
        
        // Get image data
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // Sample multiple points for better color detection
        const colorSamples = [];
        const samplePoints = 20; // Number of sample points
        
        for (let i = 0; i < samplePoints; i++) {
            const randomX = Math.floor(Math.random() * width);
            const randomY = Math.floor(Math.random() * height);
            const index = (randomY * width + randomX) * 4;
            
            if (index < data.length) {
                colorSamples.push({
                    r: data[index],
                    g: data[index + 1], 
                    b: data[index + 2]
                });
            }
        }
        
        if (colorSamples.length === 0) return '‡§Ö‡§ú‡•ç‡§û‡§æ‡§§ ‡§∞‡§Ç‡§ó';
        
        // Calculate average color
        const avgColor = colorSamples.reduce((acc, color) => ({
            r: acc.r + color.r,
            g: acc.g + color.g,
            b: acc.b + color.b
        }), {r: 0, g: 0, b: 0});
        
        avgColor.r = Math.round(avgColor.r / colorSamples.length);
        avgColor.g = Math.round(avgColor.g / colorSamples.length);
        avgColor.b = Math.round(avgColor.b / colorSamples.length);
        
        return this.getColorName(avgColor);
    }
    
    // Color name detection
    getColorName(rgb) {
        const {r, g, b} = rgb;
        
        // Advanced color detection logic
        const brightness = (r + g + b) / 3;
        
        if (brightness < 50) return '‡§ï‡§æ‡§≤‡§æ';
        if (brightness > 200 && Math.abs(r - g) < 30 && Math.abs(g - b) < 30) return '‡§∏‡§´‡•á‡§¶';
        if (brightness > 150 && brightness < 200) return '‡§∏‡•ç‡§≤‡•á‡§ü‡•Ä';
        
        // Color detection based on dominant channel
        if (r > g + 50 && r > b + 50) {
            if (g > 100) return '‡§®‡§æ‡§∞‡§Ç‡§ó‡•Ä';
            return '‡§≤‡§æ‡§≤';
        }
        
        if (g > r + 50 && g > b + 50) {
            if (r > 100) return '‡§™‡•Ä‡§≤‡§æ';
            return '‡§π‡§∞‡§æ';
        }
        
        if (b > r + 50 && b > g + 50) {
            if (r > 100) return '‡§¨‡•à‡§Ç‡§ó‡§®‡•Ä';
            return '‡§®‡•Ä‡§≤‡§æ';
        }
        
        if (r > 150 && g > 100 && b < 100) return '‡§™‡•Ä‡§≤‡§æ';
        if (r > 100 && g < 100 && b > 100) return '‡§ó‡•Å‡§≤‡§æ‡§¨‡•Ä';
        if (r > 100 && g > 50 && b < 100) return '‡§≠‡•Ç‡§∞‡§æ';
        
        return '‡§Æ‡§ø‡§∂‡•ç‡§∞‡§ø‡§§ ‡§∞‡§Ç‡§ó';
    }
    
    // Person analysis function
    analyzePersonAttributes(bbox) {
        const [x, y, width, height] = bbox;
        
        // Height analysis
        let heightCategory = '';
        if (height > 200) heightCategory = '‡§≤‡§Ç‡§¨‡§æ ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø';
        else if (height > 120) heightCategory = '‡§Æ‡§ß‡•ç‡§Ø‡§Æ ‡§ï‡§¶';
        else heightCategory = '‡§õ‡•ã‡§ü‡§æ ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø/‡§¨‡§ö‡•ç‡§ö‡§æ';
        
        // Position analysis
        let position = '';
        const centerY = y + height/2;
        const canvasHeight = this.canvas.height;
        
        if (centerY < canvasHeight * 0.3) position = '‡§ä‡§™‡§∞‡•Ä ‡§≠‡§æ‡§ó ‡§Æ‡•á‡§Ç';
        else if (centerY > canvasHeight * 0.7) position = '‡§®‡§ø‡§ö‡§≤‡•á ‡§≠‡§æ‡§ó ‡§Æ‡•á‡§Ç';
        else position = '‡§Æ‡§ß‡•ç‡§Ø ‡§Æ‡•á‡§Ç';
        
        // Movement analysis based on width
        let activity = '';
        if (width > height * 0.8) activity = '‡§¨‡•à‡§†‡§æ/‡§≤‡•á‡§ü‡§æ ‡§π‡•Å‡§Ü';
        else if (width < height * 0.4) activity = '‡§ñ‡§°‡§º‡§æ ‡§π‡•Å‡§Ü';
        else activity = '‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∏‡•ç‡§•‡§ø‡§§‡§ø';
        
        return {
            height: heightCategory,
            position: position,
            activity: activity
        };
    }
    
    getBBoxCenter(bbox) {
        const [x, y, width, height] = bbox;
        return [x + width/2, y + height/2];
    }
    
    updatePreviousDetections(predictions, currentTime) {
        // Clear old detections (older than 2 seconds)
        for (const [id, data] of this.previousDetections.entries()) {
            if (currentTime - data.time > 2000) {
                this.previousDetections.delete(id);
            }
        }
        
        // Update with current detections
        predictions.forEach(prediction => {
            this.previousDetections.set(prediction.id, {
                bbox: prediction.bbox,
                time: currentTime
            });
        });
    }
    
    drawPredictions(predictions, currentTime) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Calculate FPS
        const fps = Math.round(1000 / (currentTime - this.lastFrameTime));
        this.lastFrameTime = currentTime;
        
        // Draw FPS counter
        this.ctx.fillStyle = '#00FF00';
        this.ctx.font = 'bold 24px Arial';
        this.ctx.fillText(`FPS: ${fps}`, 20, 40);
        this.ctx.fillText(`Objects: ${predictions.length}`, 20, 70);
        
        predictions.forEach((prediction, index) => {
            const [x, y, width, height] = prediction.bbox;
            const color = this.colors[index % this.colors.length];
            
            // Enhanced bounding box with glow effect
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 4;
            this.ctx.strokeRect(x, y, width, height);
            
            // Reset shadow
            this.ctx.shadowBlur = 0;
            
            // Create detailed label with color, speed and person info
            const confidence = Math.round(prediction.score * 100);
            const speedText = prediction.speed > 1 ? `${prediction.speed} km/h ${prediction.direction}` : 'Static';
            const colorText = prediction.color ? `‡§∞‡§Ç‡§ó: ${prediction.color}` : '';
            
            let label = `${prediction.hindiName || prediction.class} (${confidence}%)`;
            if (prediction.color) {
                label += ` - ${colorText}`;
            }
            
            const speedLabel = speedText;
            
            // Person specific info
            let personInfo = '';
            if (prediction.personAttributes) {
                const attr = prediction.personAttributes;
                personInfo = `${attr.height} | ${attr.position} | ${attr.activity}`;
            }
            
            // Calculate label height based on content
            const labelHeight = personInfo ? 70 : 50;
            
            // Label background with gradient
            const gradient = this.ctx.createLinearGradient(x, y - labelHeight, x + 250, y - 10);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, color + '80');
            
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(x, y - labelHeight, Math.max(250, this.ctx.measureText(label).width + 20), labelHeight);
            
            // Label text with shadow
            this.ctx.shadowColor = 'rgba(0,0,0,0.7)';
            this.ctx.shadowBlur = 2;
            this.ctx.fillStyle = 'white';
            this.ctx.font = 'bold 14px Arial';
            this.ctx.fillText(label, x + 10, y - (labelHeight - 15));
            
            // Speed text
            this.ctx.font = 'bold 12px Arial';
            this.ctx.fillStyle = '#FFFF00';
            this.ctx.fillText(speedLabel, x + 10, y - (labelHeight - 32));
            
            // Person specific info
            if (personInfo) {
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillStyle = '#00FFFF';
                this.ctx.fillText(personInfo, x + 10, y - (labelHeight - 50));
            }
            
            // Reset shadow
            this.ctx.shadowBlur = 0;
            
            // Draw center point
            const [centerX, centerY] = this.getBBoxCenter(prediction.bbox);
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            this.ctx.fill();
        });
    }
    
    updateDetectionsList(predictions) {
        if (predictions.length === 0) {
            this.detectionsDiv.innerHTML = '<div class="detection-item">üîç ‡§ï‡•ã‡§à Object ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ</div>';
            return;
        }
        
        const detectionCounts = {};
        const speedInfo = {};
        
        predictions.forEach(prediction => {
            const className = prediction.class.toLowerCase();
            const hindiName = prediction.hindiName;
            
            if (!detectionCounts[className]) {
                detectionCounts[className] = 0;
                speedInfo[className] = {
                    hindiName,
                    maxSpeed: 0,
                    avgSpeed: 0,
                    totalSpeed: 0,
                    count: 0
                };
            }
            
            detectionCounts[className]++;
            
            if (prediction.speed > 0) {
                speedInfo[className].totalSpeed += prediction.speed;
                speedInfo[className].count++;
                speedInfo[className].maxSpeed = Math.max(speedInfo[className].maxSpeed, prediction.speed);
                speedInfo[className].avgSpeed = Math.round(speedInfo[className].totalSpeed / speedInfo[className].count);
            }
        });
        
        // Collect color and person info
        const colorInfo = {};
        const personInfo = {};
        
        predictions.forEach(prediction => {
            const className = prediction.class.toLowerCase();
            
            // Color information
            if (prediction.color && !colorInfo[className]) {
                colorInfo[className] = prediction.color;
            }
            
            // Person information
            if (prediction.personAttributes && !personInfo[className]) {
                personInfo[className] = prediction.personAttributes;
            }
        });
        
        this.detectionsDiv.innerHTML = Object.entries(detectionCounts)
            .map(([object, count]) => {
                const info = speedInfo[object];
                const speedText = info.maxSpeed > 1 ? 
                    `‚ö° Max: ${info.maxSpeed} km/h | Avg: ${info.avgSpeed} km/h` : 
                    'üöè Static';
                
                const colorText = colorInfo[object] ? `üé® ${colorInfo[object]}` : '';
                const personText = personInfo[object] ? 
                    `üë§ ${personInfo[object].height} | ${personInfo[object].activity}` : '';
                
                return `
                    <div class="detection-item advanced">
                        <div class="object-name">${info.hindiName} (${count}) ${colorText}</div>
                        <div class="speed-info">${speedText}</div>
                        ${personText ? `<div class="person-info">${personText}</div>` : ''}
                    </div>
                `;
            }).join('');
    }
    
    clearDetections() {
        this.detectionsDiv.innerHTML = '<div class="detection-item">üîç ‡§ï‡•ã‡§à Object ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ</div>';
    }
    
    updateStatus(message, type = '') {
        this.status.textContent = message;
        this.status.className = `status ${type}`;
    }
}

// Initialize the advanced object detector
document.addEventListener('DOMContentLoaded', () => {
    new AdvancedObjectDetector();
});

// Enhanced page visibility handling
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log('üîÑ Detection paused to save resources');
    } else {
        console.log('‚úÖ Detection resumed');
    }
});

// Performance monitoring
window.addEventListener('load', () => {
    console.log('üöÄ Advanced Object Detection System Loaded');
    console.log('üì± Press F for fullscreen mode');
    console.log('üéØ Supports 40+ object types with speed tracking');
});
